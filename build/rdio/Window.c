/* Window.c generated by valac 0.20.1, the Vala compiler
 * generated from Window.vala, do not modify */

/*-
 * Copyright (c) 2011-2012 Scott Ringwelski <sgringwe@mtu.edu>
 *
 * Originally Written by Scott Ringwelski for Rdio Music Player
 * Rdio Music Player: http://www.github.com/sgringwe/rdio
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <webkit/webkit.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <gio/gio.h>
#include <libsoup/soup.h>
#include <float.h>
#include <math.h>
#include <glib/gi18n-lib.h>
#include <libnotify/notify.h>


#define RDIO_TYPE_WINDOW (rdio_window_get_type ())
#define RDIO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RDIO_TYPE_WINDOW, RdioWindow))
#define RDIO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RDIO_TYPE_WINDOW, RdioWindowClass))
#define RDIO_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RDIO_TYPE_WINDOW))
#define RDIO_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RDIO_TYPE_WINDOW))
#define RDIO_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RDIO_TYPE_WINDOW, RdioWindowClass))

typedef struct _RdioWindow RdioWindow;
typedef struct _RdioWindowClass RdioWindowClass;
typedef struct _RdioWindowPrivate RdioWindowPrivate;

#define RDIO_TYPE_TOP_GRADIENT (rdio_top_gradient_get_type ())
#define RDIO_TOP_GRADIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RDIO_TYPE_TOP_GRADIENT, RdioTopGradient))
#define RDIO_TOP_GRADIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RDIO_TYPE_TOP_GRADIENT, RdioTopGradientClass))
#define RDIO_IS_TOP_GRADIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RDIO_TYPE_TOP_GRADIENT))
#define RDIO_IS_TOP_GRADIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RDIO_TYPE_TOP_GRADIENT))
#define RDIO_TOP_GRADIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RDIO_TYPE_TOP_GRADIENT, RdioTopGradientClass))

typedef struct _RdioTopGradient RdioTopGradient;
typedef struct _RdioTopGradientClass RdioTopGradientClass;

#define RDIO_TYPE_OVERLAY_LABEL (rdio_overlay_label_get_type ())
#define RDIO_OVERLAY_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RDIO_TYPE_OVERLAY_LABEL, RdioOverlayLabel))
#define RDIO_OVERLAY_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RDIO_TYPE_OVERLAY_LABEL, RdioOverlayLabelClass))
#define RDIO_IS_OVERLAY_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RDIO_TYPE_OVERLAY_LABEL))
#define RDIO_IS_OVERLAY_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RDIO_TYPE_OVERLAY_LABEL))
#define RDIO_OVERLAY_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RDIO_TYPE_OVERLAY_LABEL, RdioOverlayLabelClass))

typedef struct _RdioOverlayLabel RdioOverlayLabel;
typedef struct _RdioOverlayLabelClass RdioOverlayLabelClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define RDIO_TYPE_SETTINGS (rdio_settings_get_type ())
#define RDIO_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RDIO_TYPE_SETTINGS, RdioSettings))
#define RDIO_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RDIO_TYPE_SETTINGS, RdioSettingsClass))
#define RDIO_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RDIO_TYPE_SETTINGS))
#define RDIO_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RDIO_TYPE_SETTINGS))
#define RDIO_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RDIO_TYPE_SETTINGS, RdioSettingsClass))

typedef struct _RdioSettings RdioSettings;
typedef struct _RdioSettingsClass RdioSettingsClass;

#define RDIO_SETTINGS_TYPE_WINDOW_STATE (rdio_settings_window_state_get_type ())

#define RDIO_TYPE_MIDDLEWARE (rdio_middleware_get_type ())
#define RDIO_MIDDLEWARE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RDIO_TYPE_MIDDLEWARE, RdioMiddleware))
#define RDIO_MIDDLEWARE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RDIO_TYPE_MIDDLEWARE, RdioMiddlewareClass))
#define RDIO_IS_MIDDLEWARE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RDIO_TYPE_MIDDLEWARE))
#define RDIO_IS_MIDDLEWARE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RDIO_TYPE_MIDDLEWARE))
#define RDIO_MIDDLEWARE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RDIO_TYPE_MIDDLEWARE, RdioMiddlewareClass))

typedef struct _RdioMiddleware RdioMiddleware;
typedef struct _RdioMiddlewareClass RdioMiddlewareClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _RdioMiddlewarePrivate RdioMiddlewarePrivate;

struct _RdioWindow {
	GtkWindow parent_instance;
	RdioWindowPrivate * priv;
	WebKitWebView* webview;
};

struct _RdioWindowClass {
	GtkWindowClass parent_class;
};

struct _RdioWindowPrivate {
	RdioTopGradient* titlebar;
	RdioOverlayLabel* overlay_label;
	GtkScrolledWindow* scrolled_window;
	gboolean window_maximized;
	gchar* INJECTED_CONTROLS;
	gchar* INJECT_JS;
};

typedef enum  {
	RDIO_SETTINGS_WINDOW_STATE_NORMAL = 0,
	RDIO_SETTINGS_WINDOW_STATE_MAXIMIZED = 1,
	RDIO_SETTINGS_WINDOW_STATE_FULLSCREEN = 2
} RdioSettingsWindowState;

struct _RdioMiddleware {
	GObject parent_instance;
	RdioMiddlewarePrivate * priv;
	gboolean playing;
	gchar* title;
	gchar* album;
	gchar* artist;
	gchar* album_art;
	gint duration;
	gint position;
	gint notifications_count;
	gdouble volume;
	gint shuffle;
	gint repeat;
	gdouble zoom;
};

struct _RdioMiddlewareClass {
	GObjectClass parent_class;
};


static gpointer rdio_window_parent_class = NULL;
static GtkApplication* rdio_window__app;
static GtkApplication* rdio_window__app = NULL;

GType rdio_window_get_type (void) G_GNUC_CONST;
GType rdio_top_gradient_get_type (void) G_GNUC_CONST;
GType rdio_overlay_label_get_type (void) G_GNUC_CONST;
#define RDIO_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RDIO_TYPE_WINDOW, RdioWindowPrivate))
enum  {
	RDIO_WINDOW_DUMMY_PROPERTY
};
RdioWindow* rdio_window_new (GtkApplication* gtk_app);
RdioWindow* rdio_window_construct (GType object_type, GtkApplication* gtk_app);
GtkApplication* rdio_window_get_app (void);
RdioTopGradient* rdio_top_gradient_new (void);
RdioTopGradient* rdio_top_gradient_construct (GType object_type);
static void rdio_window_setup_cookies (RdioWindow* self);
gpointer rdio_settings_ref (gpointer instance);
void rdio_settings_unref (gpointer instance);
GParamSpec* rdio_param_spec_settings (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void rdio_value_set_settings (GValue* value, gpointer v_object);
void rdio_value_take_settings (GValue* value, gpointer v_object);
gpointer rdio_value_get_settings (const GValue* value);
GType rdio_settings_get_type (void) G_GNUC_CONST;
RdioSettings* rdio_app_get_settings (void);
gint rdio_settings_get_window_width (RdioSettings* self);
gint rdio_settings_get_window_height (RdioSettings* self);
GType rdio_settings_window_state_get_type (void) G_GNUC_CONST;
RdioSettingsWindowState rdio_settings_get_window_state (RdioSettings* self);
RdioOverlayLabel* rdio_overlay_label_new (const gchar* text);
RdioOverlayLabel* rdio_overlay_label_construct (GType object_type, const gchar* text);
static void rdio_window_on_quit (RdioWindow* self);
static void _rdio_window_on_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static gboolean rdio_window_window_state_changed (RdioWindow* self, GdkEventWindowState* event);
static gboolean _rdio_window_window_state_changed_gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self);
static void rdio_window_load_finished (RdioWindow* self, WebKitWebFrame* frame);
static void _rdio_window_load_finished_webkit_web_view_load_finished (WebKitWebView* _sender, WebKitWebFrame* p0, gpointer self);
static void rdio_window_check_internet_connection (RdioWindow* self);
static gboolean __lambda2_ (RdioWindow* self);
static gboolean ___lambda2__gsource_func (gpointer self);
gboolean rdio_utils_check_internet_connection (void);
void rdio_window_initialize_events (RdioWindow* self);
GType rdio_middleware_get_type (void) G_GNUC_CONST;
RdioMiddleware* rdio_app_get_middleware (void);
static void rdio_window_song_changed (RdioWindow* self);
static void _rdio_window_song_changed_rdio_middleware_changed (RdioMiddleware* _sender, gpointer self);
void rdio_settings_set_window_state (RdioSettings* self, RdioSettingsWindowState value);
void rdio_settings_set_window_width (RdioSettings* self, gint value);
void rdio_settings_set_window_height (RdioSettings* self, gint value);
static void rdio_window_set_app (GtkApplication* value);
static void rdio_window_finalize (GObject* obj);
static void _vala_rdio_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_rdio_window_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _rdio_window_on_quit_gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	rdio_window_on_quit (self);
}


static gboolean _rdio_window_window_state_changed_gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self) {
	gboolean result;
	result = rdio_window_window_state_changed (self, event);
	return result;
}


static void _rdio_window_load_finished_webkit_web_view_load_finished (WebKitWebView* _sender, WebKitWebFrame* p0, gpointer self) {
	rdio_window_load_finished (self, p0);
}


static gboolean __lambda2_ (RdioWindow* self) {
	gboolean result = FALSE;
	rdio_window_check_internet_connection (self);
	result = TRUE;
	return result;
}


static gboolean ___lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda2_ (self);
	return result;
}


RdioWindow* rdio_window_construct (GType object_type, GtkApplication* gtk_app) {
	RdioWindow * self = NULL;
	GtkApplication* _tmp0_;
	GtkApplication* _tmp1_;
	GdkScreen* _tmp2_ = NULL;
	GdkVisual* _tmp3_ = NULL;
	GtkOverlay* _tmp4_;
	GtkOverlay* overlay;
	GtkBox* _tmp5_;
	GtkBox* box;
	RdioTopGradient* _tmp6_;
	WebKitWebView* _tmp7_;
	GtkScrolledWindow* _tmp8_;
	GtkScrolledWindow* _tmp9_;
	GtkScrolledWindow* _tmp10_;
	WebKitWebView* _tmp11_;
	GtkBox* _tmp12_;
	RdioTopGradient* _tmp13_;
	GtkBox* _tmp14_;
	GtkScrolledWindow* _tmp15_;
	GtkOverlay* _tmp16_;
	GtkBox* _tmp17_;
	GtkOverlay* _tmp18_;
	WebKitWebView* _tmp19_;
	WebKitWebSettings* _tmp20_ = NULL;
	WebKitWebSettings* _tmp21_;
	WebKitWebSettings* settings;
	WebKitWebSettings* _tmp22_;
	WebKitWebSettings* _tmp23_;
	WebKitWebSettings* _tmp24_;
	WebKitWebSettings* _tmp25_;
	WebKitWebView* _tmp26_;
	WebKitWebSettings* _tmp27_;
	WebKitWebView* _tmp28_;
	RdioSettings* _tmp29_;
	RdioSettings* _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	RdioSettings* _tmp33_;
	RdioSettings* _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	RdioSettings* _tmp37_;
	RdioSettings* _tmp38_;
	RdioSettingsWindowState _tmp39_;
	RdioSettingsWindowState _tmp40_;
	RdioOverlayLabel* _tmp41_;
	GtkOverlay* _tmp42_;
	RdioOverlayLabel* _tmp43_;
	WebKitWebView* _tmp44_;
	g_return_val_if_fail (gtk_app != NULL, NULL);
	self = (RdioWindow*) g_object_new (object_type, NULL);
	_tmp0_ = rdio_window_get_app ();
	_tmp1_ = _tmp0_;
	gtk_window_set_application ((GtkWindow*) self, _tmp1_);
	gtk_window_set_title ((GtkWindow*) self, "");
	_tmp2_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp3_ = gdk_screen_get_rgba_visual (_tmp2_);
	gtk_widget_set_visual ((GtkWidget*) self, _tmp3_);
	g_object_set ((GtkWindow*) self, "window-position", GTK_WIN_POS_CENTER, NULL);
	gtk_window_set_default_size ((GtkWindow*) self, 1400, 700);
	_tmp4_ = (GtkOverlay*) gtk_overlay_new ();
	g_object_ref_sink (_tmp4_);
	overlay = _tmp4_;
	_tmp5_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp5_);
	box = _tmp5_;
	_tmp6_ = rdio_top_gradient_new ();
	g_object_ref_sink (_tmp6_);
	_g_object_unref0 (self->priv->titlebar);
	self->priv->titlebar = _tmp6_;
	_tmp7_ = (WebKitWebView*) webkit_web_view_new ();
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->webview);
	self->webview = _tmp7_;
	_tmp8_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->scrolled_window);
	self->priv->scrolled_window = _tmp8_;
	_tmp9_ = self->priv->scrolled_window;
	gtk_scrolled_window_set_policy (_tmp9_, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	_tmp10_ = self->priv->scrolled_window;
	_tmp11_ = self->webview;
	gtk_container_add ((GtkContainer*) _tmp10_, (GtkWidget*) _tmp11_);
	_tmp12_ = box;
	_tmp13_ = self->priv->titlebar;
	gtk_box_pack_start (_tmp12_, (GtkWidget*) _tmp13_, FALSE, FALSE, (guint) 0);
	_tmp14_ = box;
	_tmp15_ = self->priv->scrolled_window;
	gtk_box_pack_end (_tmp14_, (GtkWidget*) _tmp15_, TRUE, TRUE, (guint) 0);
	_tmp16_ = overlay;
	_tmp17_ = box;
	gtk_container_add ((GtkContainer*) _tmp16_, (GtkWidget*) _tmp17_);
	_tmp18_ = overlay;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp18_);
	_tmp19_ = self->webview;
	_tmp20_ = webkit_web_view_get_settings (_tmp19_);
	_tmp21_ = _g_object_ref0 (_tmp20_);
	settings = _tmp21_;
	_tmp22_ = settings;
	g_object_set (_tmp22_, "enable-plugins", TRUE, NULL);
	_tmp23_ = settings;
	g_object_set (_tmp23_, "enable-private-browsing", TRUE, NULL);
	_tmp24_ = settings;
	g_object_set (_tmp24_, "enable-page-cache", TRUE, NULL);
	_tmp25_ = settings;
	g_object_set (_tmp25_, "enable-default-context-menu", FALSE, NULL);
	_tmp26_ = self->webview;
	_tmp27_ = settings;
	webkit_web_view_set_settings (_tmp26_, _tmp27_);
	rdio_window_setup_cookies (self);
	_tmp28_ = self->webview;
	webkit_web_view_open (_tmp28_, "https://www.rdio.com/browse/charts/albums/");
	_tmp29_ = rdio_app_get_settings ();
	_tmp30_ = _tmp29_;
	_tmp31_ = rdio_settings_get_window_width (_tmp30_);
	_tmp32_ = _tmp31_;
	_tmp33_ = rdio_app_get_settings ();
	_tmp34_ = _tmp33_;
	_tmp35_ = rdio_settings_get_window_height (_tmp34_);
	_tmp36_ = _tmp35_;
	gtk_window_set_default_size ((GtkWindow*) self, _tmp32_, _tmp36_);
	_tmp37_ = rdio_app_get_settings ();
	_tmp38_ = _tmp37_;
	_tmp39_ = rdio_settings_get_window_state (_tmp38_);
	_tmp40_ = _tmp39_;
	if (_tmp40_ == RDIO_SETTINGS_WINDOW_STATE_MAXIMIZED) {
		self->priv->window_maximized = TRUE;
		gtk_window_maximize ((GtkWindow*) self);
	}
	_tmp41_ = rdio_overlay_label_new ("No Internet Connection");
	g_object_ref_sink (_tmp41_);
	_g_object_unref0 (self->priv->overlay_label);
	self->priv->overlay_label = _tmp41_;
	_tmp42_ = overlay;
	_tmp43_ = self->priv->overlay_label;
	gtk_overlay_add_overlay (_tmp42_, (GtkWidget*) _tmp43_);
	gtk_widget_show_all ((GtkWidget*) self);
	g_signal_connect_object ((GtkWidget*) self, "destroy", (GCallback) _rdio_window_on_quit_gtk_widget_destroy, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "window-state-event", (GCallback) _rdio_window_window_state_changed_gtk_widget_window_state_event, self, 0);
	_tmp44_ = self->webview;
	g_signal_connect_object (_tmp44_, "load-finished", (GCallback) _rdio_window_load_finished_webkit_web_view_load_finished, self, 0);
	rdio_window_check_internet_connection (self);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 15000, ___lambda2__gsource_func, g_object_ref (self), g_object_unref);
	_g_object_unref0 (settings);
	_g_object_unref0 (box);
	_g_object_unref0 (overlay);
	return self;
}


RdioWindow* rdio_window_new (GtkApplication* gtk_app) {
	return rdio_window_construct (RDIO_TYPE_WINDOW, gtk_app);
}


static void rdio_window_check_internet_connection (RdioWindow* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = rdio_utils_check_internet_connection ();
	if (_tmp0_) {
		RdioOverlayLabel* _tmp1_;
		_tmp1_ = self->priv->overlay_label;
		gtk_widget_set_visible ((GtkWidget*) _tmp1_, FALSE);
	} else {
		RdioOverlayLabel* _tmp2_;
		_tmp2_ = self->priv->overlay_label;
		gtk_widget_set_visible ((GtkWidget*) _tmp2_, TRUE);
	}
}


static void rdio_window_load_finished (RdioWindow* self, WebKitWebFrame* frame) {
	WebKitWebView* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (frame != NULL);
	_tmp0_ = self->webview;
	_tmp1_ = self->priv->INJECT_JS;
	_tmp2_ = self->priv->INJECTED_CONTROLS;
	_tmp3_ = g_strdup_printf (_tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	webkit_web_view_execute_script (_tmp0_, _tmp4_);
	_g_free0 (_tmp4_);
}


static void _rdio_window_song_changed_rdio_middleware_changed (RdioMiddleware* _sender, gpointer self) {
	rdio_window_song_changed (self);
}


void rdio_window_initialize_events (RdioWindow* self) {
	RdioMiddleware* _tmp0_;
	RdioMiddleware* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = rdio_app_get_middleware ();
	_tmp1_ = _tmp0_;
	g_signal_connect_object (_tmp1_, "changed", (GCallback) _rdio_window_song_changed_rdio_middleware_changed, self, 0);
}


static void rdio_window_setup_cookies (RdioWindow* self) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_;
	GFile* user_rdio_folder;
	GFile* _tmp5_;
	gboolean _tmp6_ = FALSE;
	GFile* _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* user_rdio_cookie_file;
	SoupSession* _tmp15_ = NULL;
	SoupSession* _tmp16_;
	SoupSession* session;
	SoupCookieJarText* _tmp17_;
	SoupCookieJarText* cookiejar;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_get_user_data_dir ();
	_tmp1_ = g_build_filename (_tmp0_, "rdio", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	user_rdio_folder = _tmp4_;
	_tmp5_ = user_rdio_folder;
	_tmp6_ = g_file_query_exists (_tmp5_, NULL);
	if (!_tmp6_) {
		{
			GFile* _tmp7_;
			_tmp7_ = user_rdio_folder;
			g_file_make_directory_with_parents (_tmp7_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch0_g_error;
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* err = NULL;
			GError* _tmp8_;
			const gchar* _tmp9_;
			err = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = err;
			_tmp9_ = _tmp8_->message;
			g_critical ("Window.vala:143: Could not create beatbox folder in data directory: %s" \
"\n", _tmp9_);
			_g_error_free0 (err);
		}
		__finally0:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (user_rdio_folder);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp10_ = user_rdio_folder;
	_tmp11_ = g_file_get_path (_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = g_build_filename (_tmp12_, "cookies.dat", NULL);
	_tmp14_ = _tmp13_;
	_g_free0 (_tmp12_);
	user_rdio_cookie_file = _tmp14_;
	_tmp15_ = webkit_get_default_session ();
	_tmp16_ = _g_object_ref0 (_tmp15_);
	session = _tmp16_;
	_tmp17_ = (SoupCookieJarText*) soup_cookie_jar_text_new (user_rdio_cookie_file, FALSE);
	cookiejar = _tmp17_;
	soup_session_add_feature (session, (SoupSessionFeature*) cookiejar);
	_g_object_unref0 (cookiejar);
	_g_object_unref0 (session);
	_g_free0 (user_rdio_cookie_file);
	_g_object_unref0 (user_rdio_folder);
}


static void rdio_window_song_changed (RdioWindow* self) {
	RdioMiddleware* _tmp0_;
	RdioMiddleware* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	RdioMiddleware* _tmp12_;
	RdioMiddleware* _tmp13_;
	const gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	const gchar* _tmp19_ = NULL;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	RdioMiddleware* _tmp24_;
	RdioMiddleware* _tmp25_;
	const gchar* _tmp26_;
	gchar* _tmp27_;
	gchar* _tmp28_;
	g_return_if_fail (self != NULL);
	_tmp0_ = rdio_app_get_middleware ();
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_->title;
	_tmp3_ = g_strconcat ("DEV | ", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, " ", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = _ ("by");
	_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strconcat (_tmp9_, " ", NULL);
	_tmp11_ = _tmp10_;
	_tmp12_ = rdio_app_get_middleware ();
	_tmp13_ = _tmp12_;
	_tmp14_ = _tmp13_->artist;
	_tmp15_ = g_strconcat (_tmp11_, _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp16_, " ", NULL);
	_tmp18_ = _tmp17_;
	_tmp19_ = _ ("on");
	_tmp20_ = g_strconcat (_tmp18_, _tmp19_, NULL);
	_tmp21_ = _tmp20_;
	_tmp22_ = g_strconcat (_tmp21_, " ", NULL);
	_tmp23_ = _tmp22_;
	_tmp24_ = rdio_app_get_middleware ();
	_tmp25_ = _tmp24_;
	_tmp26_ = _tmp25_->album;
	_tmp27_ = g_strconcat (_tmp23_, _tmp26_, NULL);
	_tmp28_ = _tmp27_;
	gtk_window_set_title ((GtkWindow*) self, _tmp28_);
	_g_free0 (_tmp28_);
	_g_free0 (_tmp23_);
	_g_free0 (_tmp21_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
}


static gboolean rdio_window_window_state_changed (RdioWindow* self, GdkEventWindowState* event) {
	gboolean result = FALSE;
	GdkEventWindowState _tmp0_;
	GdkWindowState _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.new_window_state;
	self->priv->window_maximized = (_tmp1_ & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_FULLSCREEN)) != 0;
	result = FALSE;
	return result;
}


static void rdio_window_on_quit (RdioWindow* self) {
	guint _tmp0_ = 0U;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	g_signal_parse_name ("window-state-event", GTK_TYPE_WIDGET, &_tmp0_, NULL, FALSE);
	g_signal_handlers_disconnect_matched ((GtkWidget*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _rdio_window_window_state_changed_gtk_widget_window_state_event, self);
	notify_uninit ();
	_tmp1_ = self->priv->window_maximized;
	if (_tmp1_) {
		RdioSettings* _tmp2_;
		RdioSettings* _tmp3_;
		_tmp2_ = rdio_app_get_settings ();
		_tmp3_ = _tmp2_;
		rdio_settings_set_window_state (_tmp3_, RDIO_SETTINGS_WINDOW_STATE_MAXIMIZED);
	} else {
		RdioSettings* _tmp4_;
		RdioSettings* _tmp5_;
		RdioSettings* _tmp6_;
		RdioSettings* _tmp7_;
		gint _tmp8_ = 0;
		RdioSettings* _tmp9_;
		RdioSettings* _tmp10_;
		gint _tmp11_ = 0;
		_tmp4_ = rdio_app_get_settings ();
		_tmp5_ = _tmp4_;
		rdio_settings_set_window_state (_tmp5_, RDIO_SETTINGS_WINDOW_STATE_NORMAL);
		_tmp6_ = rdio_app_get_settings ();
		_tmp7_ = _tmp6_;
		_tmp8_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
		rdio_settings_set_window_width (_tmp7_, _tmp8_);
		_tmp9_ = rdio_app_get_settings ();
		_tmp10_ = _tmp9_;
		_tmp11_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
		rdio_settings_set_window_height (_tmp10_, _tmp11_);
	}
}


GtkApplication* rdio_window_get_app (void) {
	GtkApplication* result;
	GtkApplication* _tmp0_;
	_tmp0_ = rdio_window__app;
	result = _tmp0_;
	return result;
}


static void rdio_window_set_app (GtkApplication* value) {
	GtkApplication* _tmp0_;
	GtkApplication* _tmp1_;
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (rdio_window__app);
	rdio_window__app = _tmp1_;
}


static void rdio_window_class_init (RdioWindowClass * klass) {
	rdio_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RdioWindowPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_rdio_window_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_rdio_window_set_property;
	G_OBJECT_CLASS (klass)->finalize = rdio_window_finalize;
}


static void rdio_window_instance_init (RdioWindow * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	self->priv = RDIO_WINDOW_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("<nav id=\"injectedNavigationControls\" class=\"ViewToggle clearfix\" s" \
"tyle=\"float: left; margin: 20px 0px 20px 25px;\"><ul><li class=\"firs" \
"t\"><a href=\"#\" onclick=\"history.back();\">&lt;</a></li><li class=\"" \
"last\"><a href=\"#\" onclick=\"history.forward();\">&gt;</a></li></ul>" \
"</nav>");
	self->priv->INJECTED_CONTROLS = _tmp0_;
	_tmp1_ = g_strdup ("\n" \
"\t\tvar timer = null;\n" \
"\t\ttimer = setInterval(function(){\n" \
"            if ($('#injectedNavigationControls').length == 0) {\n" \
"\t\t\t\t$('#header').prepend('%s');\n" \
"\t\t\t\tconsole.log('injecting into header');\n" \
"            }\n" \
"        },1000);\n" \
"\t");
	self->priv->INJECT_JS = _tmp1_;
}


static void rdio_window_finalize (GObject* obj) {
	RdioWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, RDIO_TYPE_WINDOW, RdioWindow);
	_g_object_unref0 (self->priv->titlebar);
	_g_object_unref0 (self->priv->overlay_label);
	_g_object_unref0 (self->webview);
	_g_object_unref0 (self->priv->scrolled_window);
	_g_free0 (self->priv->INJECTED_CONTROLS);
	_g_free0 (self->priv->INJECT_JS);
	G_OBJECT_CLASS (rdio_window_parent_class)->finalize (obj);
}


GType rdio_window_get_type (void) {
	static volatile gsize rdio_window_type_id__volatile = 0;
	if (g_once_init_enter (&rdio_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RdioWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rdio_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RdioWindow), 0, (GInstanceInitFunc) rdio_window_instance_init, NULL };
		GType rdio_window_type_id;
		rdio_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "RdioWindow", &g_define_type_info, 0);
		g_once_init_leave (&rdio_window_type_id__volatile, rdio_window_type_id);
	}
	return rdio_window_type_id__volatile;
}


static void _vala_rdio_window_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	RdioWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, RDIO_TYPE_WINDOW, RdioWindow);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_rdio_window_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	RdioWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, RDIO_TYPE_WINDOW, RdioWindow);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



